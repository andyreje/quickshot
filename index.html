<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>一键短片 3D 演示</title>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #eef2f5; font-family: 'Segoe UI', sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }

        /* UI 层 */
        .ui-layer {
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 15px; z-index: 10;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(15px);
            padding: 15px 25px; border-radius: 24px;
            box-shadow: 0 15px 50px rgba(0,0,0,0.1);
            border: 1px solid rgba(255,255,255,0.5);
        }
        .mode-btn {
            border: none; background: transparent; color: #555;
            padding: 10px 18px; border-radius: 12px; font-size: 15px; font-weight: 700;
            cursor: pointer; transition: all 0.2s ease-out;
            display: flex; flex-direction: column; align-items: center; min-width: 70px;
            position: relative; overflow: hidden;
        }
        .mode-btn::before {
            content: ''; position: absolute; top:0; left:0; width:100%; height:100%;
            background: #0070f0; opacity: 0; transition: opacity 0.2s; z-index: -1;
        }
        .mode-btn:hover { color: #0070f0; transform: translateY(-2px); }
        .mode-btn.active { color: white; transform: translateY(-2px); }
        .mode-btn.active::before { opacity: 1; }
        .mode-desc { font-size: 9px; margin-top: 3px; opacity: 0.8; font-weight: 500; text-transform: uppercase; }

        .top-bar { position: absolute; top: 0; left: 0; width: 100%; padding: 30px; box-sizing: border-box; pointer-events: none; }
        .title-box h1 { margin: 0; font-size: 28px; color: #222; letter-spacing: -0.5px; }
        .title-box p { margin: 8px 0 0 0; color: #555; font-size: 14px; background: rgba(255,255,255,0.8); padding: 6px 12px; border-radius: 6px; display: inline-block; backdrop-filter: blur(5px); }

        #status-text {
            position: absolute; top: 15%; left: 50%; transform: translate(-50%, -50%);
            font-size: 70px; font-weight: 900; color: rgba(0, 112, 240, 0.06);
            pointer-events: none; text-transform: uppercase; letter-spacing: 10px;
            white-space: nowrap; transition: opacity 0.3s;
        }
    </style>
</head>
<body>

    <div class="top-bar">
        <div class="title-box">
            <h1>QuickShots Pro</h1>
            <p>全域3D一键短片演示</p>
        </div>
    </div>

    <div id="status-text">READY</div>

    <div class="ui-layer">
        <button class="mode-btn" onclick="playMode('dronie', this)"><span>渐远</span><span class="mode-desc">Dronie</span></button>
        <button class="mode-btn" onclick="playMode('rocket', this)"><span>冲天</span><span class="mode-desc">Rocket</span></button>
        <button class="mode-btn" onclick="playMode('circle', this)"><span>环绕</span><span class="mode-desc">Circle</span></button>
        <button class="mode-btn" onclick="playMode('helix', this)"><span>螺旋</span><span class="mode-desc">Helix</span></button>
        <button class="mode-btn" onclick="playMode('boomerang', this)"><span>彗星</span><span class="mode-desc">Boomerang</span></button>
    </div>

    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- 场景配置 ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xeef2f5);
        scene.fog = new THREE.Fog(0xeef2f5, 1000, 8000);

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.5, 10000);
        camera.position.set(0, 80, 160);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.maxDistance = 2000;
        controls.maxPolarAngle = Math.PI / 2 - 0.05;

        // --- 环境 (已移除 GridHelper) ---
        // 这里删除了 gridHelper 的代码
        
        // 地面平面 (保留，用于接收阴影)
        const plane = new THREE.Mesh(
            new THREE.PlaneGeometry(10000, 10000), 
            new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 1.0, metalness: 0.0 }) // 纯白哑光地面
        );
        plane.rotation.x = -Math.PI / 2; 
        plane.position.y = -0.2; 
        plane.receiveShadow = true;
        scene.add(plane);

        const hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.7);
        scene.add(hemiLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(200, 400, 200);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.set(4096, 4096);
        const d = 500;
        dirLight.shadow.camera.left = -d; dirLight.shadow.camera.right = d; dirLight.shadow.camera.top = d; dirLight.shadow.camera.bottom = -d;
        scene.add(dirLight);

        // --- 目标 (人物) ---
        const targetGroup = new THREE.Group();
        scene.add(targetGroup);
        const tMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
        const tBody = new THREE.Mesh(new THREE.CylinderGeometry(1.6, 1.6, 7), tMat); tBody.position.y = 3.5;
        const tHead = new THREE.Mesh(new THREE.SphereGeometry(2), tMat); tHead.position.y = 8;
        targetGroup.add(tBody, tHead);
        targetGroup.castShadow = true;
        const ring = new THREE.Mesh(new THREE.RingGeometry(3, 4.5, 64), new THREE.MeshBasicMaterial({ color: 0x0070f0, side: THREE.DoubleSide, transparent: true, opacity: 0.6 }));
        ring.rotation.x = -Math.PI / 2; ring.position.y = 0.1;
        targetGroup.add(ring);

        // --- 无人机系统 ---
        const droneGroup = new THREE.Group();
        scene.add(droneGroup);
        droneGroup.scale.set(1.8, 1.8, 1.8);

        const whiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.4 });
        const darkMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.6 });
        const orangeMat = new THREE.MeshStandardMaterial({ color: 0xff6600, roughness: 0.4 });

        // 机身
        const body = new THREE.Mesh(new THREE.BoxGeometry(4, 1.5, 6), whiteMat);
        body.castShadow = true;
        droneGroup.add(body);
        
        // 机臂
        const armGeo = new THREE.BoxGeometry(16, 0.5, 1.5);
        const arm1 = new THREE.Mesh(armGeo, whiteMat); arm1.rotation.y = Math.PI/4; droneGroup.add(arm1);
        const arm2 = new THREE.Mesh(armGeo, whiteMat); arm2.rotation.y = -Math.PI/4; droneGroup.add(arm2);

        // 螺旋桨
        const propGeo = new THREE.CylinderGeometry(3, 3, 0.05, 16);
        const propMat = new THREE.MeshStandardMaterial({color: 0xcccccc, transparent:true, opacity:0.4});
        const orangePropMat = new THREE.MeshStandardMaterial({color: 0xffaa00, transparent:true, opacity:0.6});

        // 桨叶位置 (Z>0 为前)
        const props = [
            {x:5.5, z:5.5, isFront: true}, {x:-5.5, z:5.5, isFront: true}, 
            {x:5.5, z:-5.5, isFront: false}, {x:-5.5, z:-5.5, isFront: false}
        ];
        props.forEach(p => {
            const m = new THREE.Mesh(new THREE.CylinderGeometry(0.8,0.8,1), darkMat); m.position.set(p.x, 0.5, p.z); droneGroup.add(m);
            const pm = p.isFront ? orangePropMat : propMat;
            const prop = new THREE.Mesh(propGeo, pm); prop.position.y = 0.6; m.add(prop);
            const cap = new THREE.Mesh(new THREE.CylinderGeometry(0.3,0.3,0.2), p.isFront ? orangeMat : darkMat); cap.position.y = 0.7; m.add(cap);
            prop.userData = { isProp: true };
        });

        // 绿色机头指示
        const noseMesh = new THREE.Mesh(new THREE.BoxGeometry(2, 0.8, 1), new THREE.MeshBasicMaterial({color: 0x00ff00}));
        noseMesh.position.set(0, 0, 3.2); 
        droneGroup.add(noseMesh);
        const coneMesh = new THREE.Mesh(new THREE.ConeGeometry(0.5, 8, 16), new THREE.MeshBasicMaterial({color: 0x00ff00, transparent:true, opacity:0.3}));
        coneMesh.rotation.x = Math.PI/2; coneMesh.position.set(0, 0, 8);
        droneGroup.add(coneMesh);

        // 云台相机
        const gimbal = new THREE.Group();
        gimbal.position.set(0, -1.2, 2.5);
        droneGroup.add(gimbal);
        const camBox = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1.5, 2), darkMat);
        gimbal.add(camBox);
        const lens = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.6, 0.5), new THREE.MeshBasicMaterial({color:0x111111}));
        lens.rotation.x = Math.PI/2; lens.position.z = 1;
        camBox.add(lens);
        
        // 视野锥 (从镜头出发，向前)
        const coneGeo = new THREE.ConeGeometry(0.4, 25, 32, 1, true);
        coneGeo.translate(0, -12.5, 0); 
        coneGeo.rotateX(-Math.PI/2); 
        const cone = new THREE.Mesh(coneGeo, new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.15, depthWrite: false, side: THREE.DoubleSide}));
        cone.scale.set(10, 10, 10);
        gimbal.add(cone);

        // --- 轨迹系统 ---
        const MAX_POINTS = 2000;
        const trailGeo = new THREE.BufferGeometry();
        const positions = new Float32Array(MAX_POINTS * 3);
        trailGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        const trailMat = new THREE.LineBasicMaterial({ color: 0xfcb813, linewidth: 3 });
        const trailLine = new THREE.Line(trailGeo, trailMat);
        scene.add(trailLine);

        let trailCount = 0;
        let lastPos = new THREE.Vector3();

        function resetTrail() {
            trailCount = 0;
            trailGeo.setDrawRange(0, 0);
        }

        function updateTrail(pos) {
            if (pos.distanceTo(lastPos) > 1.5) {
                if (trailCount < MAX_POINTS) {
                    positions[trailCount * 3] = pos.x;
                    positions[trailCount * 3 + 1] = pos.y;
                    positions[trailCount * 3 + 2] = pos.z;
                    trailCount++;
                    trailGeo.setDrawRange(0, trailCount);
                    trailGeo.attributes.position.needsUpdate = true;
                    lastPos.copy(pos);
                }
            }
        }

        // --- 动画逻辑 ---
        const state = { mode: 'idle', t: 0, speed: 0.003, startPos: new THREE.Vector3(), targetLookAt: new THREE.Vector3(0, 4, 0) };
        const statusText = document.getElementById('status-text');

        function animate() {
            requestAnimationFrame(animate);
            droneGroup.traverse(obj => { if (obj.userData.isProp) obj.rotation.y += 1.2; });

            if (state.mode !== 'idle') {
                state.t += state.speed;
                const dronePos = new THREE.Vector3();
                
                if (state.mode === 'dronie') {
                    const dist = 150 * state.t;
                    const height = 80 * state.t;
                    dronePos.copy(state.startPos).add(new THREE.Vector3(0, height, dist));
                    droneGroup.lookAt(state.targetLookAt);
                    gimbal.rotation.set(0,0,0);
                }
                else if (state.mode === 'rocket') {
                    const height = 120 * state.t;
                    dronePos.copy(state.startPos).setY(10 + height);
                    droneGroup.rotation.set(0, 0, 0); 
                    gimbal.lookAt(state.targetLookAt); 
                }
                else if (state.mode === 'circle') {
                    const radius = 65; 
                    const angle = state.t * Math.PI * 2; 
                    dronePos.x = Math.sin(angle) * radius;
                    dronePos.z = Math.cos(angle) * radius;
                    dronePos.y = 20; 
                    droneGroup.lookAt(state.targetLookAt);
                    gimbal.rotation.set(0,0,0);
                }
                else if (state.mode === 'helix') {
                    const angle = state.t * Math.PI * 4; 
                    const radius = 15 + 80 * state.t; 
                    const height = 10 + 70 * state.t; 
                    dronePos.x = Math.sin(angle) * radius;
                    dronePos.z = Math.cos(angle) * radius;
                    dronePos.y = height;
                    droneGroup.lookAt(state.targetLookAt);
                    gimbal.rotation.set(0,0,0);
                }
                else if (state.mode === 'boomerang') {
                    const startAngle = Math.PI / 4; 
                    const totalAngle = Math.PI * 2;
                    const currentAngle = startAngle + totalAngle * state.t;
                    const widthX = 50; const depthZ = 100; 
                    dronePos.x = Math.sin(currentAngle) * widthX;
                    dronePos.z = Math.cos(currentAngle) * depthZ;
                    dronePos.y = 40 + (-dronePos.z * 0.35);
                    if(dronePos.y < 5) dronePos.y = 5;
                    droneGroup.lookAt(state.targetLookAt);
                    gimbal.rotation.set(0,0,0);
                }

                droneGroup.position.copy(dronePos);
                updateTrail(dronePos);

                if (state.t >= 1) {
                    state.mode = 'idle';
                    statusText.style.opacity = 0;
                }
            } else {
                const time = Date.now() * 0.001;
                droneGroup.position.y += Math.sin(time) * 0.02;
            }
            controls.update();
            renderer.render(scene, camera);
        }

        window.playMode = function(modeName, btn) {
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            resetTrail();
            state.t = 0;
            state.mode = modeName;
            state.speed = 0.002;

            if (modeName === 'dronie') {
                state.startPos.set(0, 5, 10);
                statusText.innerText = "渐远 DRONIE";
            } else if (modeName === 'rocket') {
                state.startPos.set(0, 5, 0.1); 
                statusText.innerText = "冲天 ROCKET";
            } else if (modeName === 'circle') {
                state.startPos.set(0, 20, 65);
                state.speed = 0.0015;
                statusText.innerText = "环绕 CIRCLE";
            } else if (modeName === 'helix') {
                state.startPos.set(0, 10, 15);
                statusText.innerText = "螺旋 HELIX";
            } else if (modeName === 'boomerang') {
                const ang = Math.PI/4;
                state.startPos.set(Math.sin(ang)*50, 40+(-Math.cos(ang)*100*0.35), Math.cos(ang)*100);
                statusText.innerText = "彗星 BOOMERANG";
            }
            
            droneGroup.position.copy(state.startPos);
            if(modeName !== 'rocket') droneGroup.lookAt(state.targetLookAt);
            else droneGroup.rotation.set(0,0,0);
            
            statusText.style.opacity = 1;
            statusText.style.transform = "translate(-50%, -50%) scale(1.1)";
            setTimeout(() => statusText.style.transform = "translate(-50%, -50%) scale(1)", 100);
        };

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        animate();
    </script>
</body>
</html>
