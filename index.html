<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>一键短片 3D 演示</title>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #eef2f5; font-family: 'Segoe UI', sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }

        /* UI 层 */
        .ui-layer {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            z-index: 10;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(15px);
            padding: 15px 25px;
            border-radius: 24px;
            box-shadow: 0 15px 50px rgba(0,0,0,0.1);
            border: 1px solid rgba(255,255,255,0.5);
        }

        .mode-btn {
            border: none;
            background: transparent;
            color: #555;
            padding: 10px 18px;
            border-radius: 12px;
            font-size: 15px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s ease-out;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 70px;
            position: relative;
            overflow: hidden;
        }

        .mode-btn::before {
            content: ''; position: absolute; top:0; left:0; width:100%; height:100%;
            background: #0070f0; opacity: 0; transition: opacity 0.2s; z-index: -1;
        }

        .mode-btn:hover { color: #0070f0; transform: translateY(-2px); }

        .mode-btn.active { color: white; transform: translateY(-2px); }
        .mode-btn.active::before { opacity: 1; }

        .mode-desc {
            font-size: 9px; margin-top: 3px; opacity: 0.8;
            font-weight: 500; text-transform: uppercase; letter-spacing: 0.5px;
        }

        /* 顶部标题 */
        .top-bar {
            position: absolute; top: 0; left: 0; width: 100%;
            padding: 30px;
            box-sizing: border-box;
            pointer-events: none;
        }
        .title-box h1 { margin: 0; font-size: 28px; color: #222; letter-spacing: -0.5px; }
        .title-box p { 
            margin: 8px 0 0 0; color: #555; font-size: 14px; 
            background: rgba(255,255,255,0.8); padding: 6px 12px; border-radius: 6px; 
            display: inline-block; backdrop-filter: blur(5px);
        }

        /* 大字状态提示 */
        #status-text {
            position: absolute; top: 15%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 70px; font-weight: 900;
            color: rgba(0, 112, 240, 0.06);
            pointer-events: none;
            text-transform: uppercase; letter-spacing: 10px;
            white-space: nowrap; transition: opacity 0.3s;
        }
    </style>
</head>
<body>

    <div class="top-bar">
        <div class="title-box">
            <h1>QuickShots Pro</h1>
            <p>全域轨迹演示系统</p>
        </div>
    </div>

    <div id="status-text">READY</div>

    <div class="ui-layer">
        <button class="mode-btn" onclick="playMode('dronie', this)">
            <span>渐远</span><span class="mode-desc">Dronie</span>
        </button>
        <button class="mode-btn" onclick="playMode('rocket', this)">
            <span>冲天</span><span class="mode-desc">Rocket</span>
        </button>
        <button class="mode-btn" onclick="playMode('circle', this)">
            <span>环绕</span><span class="mode-desc">Circle</span>
        </button>
        <button class="mode-btn" onclick="playMode('helix', this)">
            <span>螺旋</span><span class="mode-desc">Helix</span>
        </button>
        <button class="mode-btn" onclick="playMode('boomerang', this)">
            <span>彗星</span><span class="mode-desc">Boomerang</span>
        </button>
    </div>

    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- 场景配置 ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xeef2f5);
        scene.fog = new THREE.Fog(0xeef2f5, 1000, 8000); // 极远可视距离

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.5, 10000);
        camera.position.set(0, 80, 160); // 初始视角放在正前方稍微偏高

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.maxDistance = 2000;
        // 限制仰角，防止穿模到底下
        controls.maxPolarAngle = Math.PI / 2 - 0.05;

        // --- 宏大场景构建 ---
        // 地面
        const gridHelper = new THREE.GridHelper(4000, 200, 0xd0dbe6, 0xffffff);
        scene.add(gridHelper);
        const plane = new THREE.Mesh(
            new THREE.PlaneGeometry(10000, 10000), 
            new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.9 })
        );
        plane.rotation.x = -Math.PI / 2;
        plane.position.y = -0.2;
        plane.receiveShadow = true;
        scene.add(plane);

        // 灯光
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.7);
        scene.add(hemiLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(200, 400, 200);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.set(4096, 4096);
        const d = 500;
        dirLight.shadow.camera.left = -d; dirLight.shadow.camera.right = d;
        dirLight.shadow.camera.top = d; dirLight.shadow.camera.bottom = -d;
        scene.add(dirLight);

        // --- 拍摄目标 (中心人物) ---
        const targetGroup = new THREE.Group();
        scene.add(targetGroup);
        const tMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
        const tBody = new THREE.Mesh(new THREE.CylinderGeometry(1.6, 1.6, 7), tMat); tBody.position.y = 3.5;
        const tHead = new THREE.Mesh(new THREE.SphereGeometry(2), tMat); tHead.position.y = 8;
        targetGroup.add(tBody, tHead);
        targetGroup.castShadow = true;
        // 目标底座指示圈
        const ring = new THREE.Mesh(new THREE.RingGeometry(3, 4.5, 64), new THREE.MeshBasicMaterial({ color: 0x0070f0, side: THREE.DoubleSide, transparent: true, opacity: 0.6 }));
        ring.rotation.x = -Math.PI / 2; ring.position.y = 0.1;
        targetGroup.add(ring);


        // --- 无人机系统 ---
        const droneGroup = new THREE.Group();
        scene.add(droneGroup);
        // 稍微放大一点无人机以便远观
        droneGroup.scale.set(1.8, 1.8, 1.8);

        // 材质
        const whiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.4 });
        const darkMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.6 });

        // 机身
        const body = new THREE.Mesh(new THREE.BoxGeometry(4, 1.5, 6), whiteMat);
        body.castShadow = true;
        droneGroup.add(body);
        // 机臂
        const armGeo = new THREE.BoxGeometry(16, 0.5, 1.5);
        const arm1 = new THREE.Mesh(armGeo, whiteMat); arm1.rotation.y = Math.PI/4; droneGroup.add(arm1);
        const arm2 = new THREE.Mesh(armGeo, whiteMat); arm2.rotation.y = -Math.PI/4; droneGroup.add(arm2);
        // 螺旋桨
        const propGeo = new THREE.CylinderGeometry(3, 3, 0.05, 16);
        const propMat = new THREE.MeshStandardMaterial({color: 0xcccccc, transparent:true, opacity:0.4});
        [{x:5.5,z:-5.5}, {x:-5.5,z:-5.5}, {x:5.5,z:5.5}, {x:-5.5,z:5.5}].forEach(p => {
            const m = new THREE.Mesh(new THREE.CylinderGeometry(0.8,0.8,1), darkMat); m.position.set(p.x, 0.5, p.z); droneGroup.add(m);
            const prop = new THREE.Mesh(propGeo, propMat); prop.position.y = 0.6; m.add(prop);
            prop.userData = { isProp: true };
        });

        // 云台相机
        const gimbal = new THREE.Group();
        gimbal.position.set(0, -1.2, -2.5);
        droneGroup.add(gimbal);
        const camBox = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1.5, 2), darkMat);
        gimbal.add(camBox);
        const lens = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.6, 0.5), new THREE.MeshBasicMaterial({color:0x111111}));
        lens.rotation.x = Math.PI/2; lens.position.z = -1;
        camBox.add(lens);
        
        // 绿色视野线 (指示拍摄方向)
        const coneGeo = new THREE.ConeGeometry(0.4, 25, 32, 1, true);
        coneGeo.translate(0, -12.5, 0);
        coneGeo.rotateX(-Math.PI/2);
        const cone = new THREE.Mesh(coneGeo, new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.15, depthWrite: false, side: THREE.DoubleSide}));
        cone.scale.set(10, 10, 10);
        gimbal.add(cone);


        // --- 轨迹系统 ---
        const MAX_POINTS = 2000;
        const trailGeo = new THREE.BufferGeometry();
        const positions = new Float32Array(MAX_POINTS * 3);
        trailGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        const trailMat = new THREE.LineBasicMaterial({ color: 0xfcb813, linewidth: 3 });
        const trailLine = new THREE.Line(trailGeo, trailMat);
        // 让轨迹稍微浮起一点点，避免和地面z-fighting (虽然主要是在空中)
        scene.add(trailLine);

        let trailCount = 0;
        let lastPos = new THREE.Vector3();

        function resetTrail() {
            trailCount = 0;
            trailGeo.setDrawRange(0, 0);
        }

        function updateTrail(pos) {
            // 距离阈值稍微大一点，减少点的数量
            if (pos.distanceTo(lastPos) > 1.5) {
                if (trailCount < MAX_POINTS) {
                    positions[trailCount * 3] = pos.x;
                    positions[trailCount * 3 + 1] = pos.y;
                    positions[trailCount * 3 + 2] = pos.z;
                    trailCount++;
                    trailGeo.setDrawRange(0, trailCount);
                    trailGeo.attributes.position.needsUpdate = true;
                    lastPos.copy(pos);
                }
            }
        }


        // --- 动画核心逻辑 ---
        const state = {
            mode: 'idle',
            t: 0,
            speed: 0.003,
            startPos: new THREE.Vector3(),
            targetLookAt: new THREE.Vector3(0, 4, 0) // 看向人头
        };

        const statusText = document.getElementById('status-text');

        function animate() {
            requestAnimationFrame(animate);

            // 1. 螺旋桨动画
            droneGroup.traverse(obj => { if (obj.userData.isProp) obj.rotation.y += 1.2; });

            if (state.mode !== 'idle') {
                state.t += state.speed;
                const dronePos = new THREE.Vector3();
                
                // --- 渐远 (Dronie) ---
                if (state.mode === 'dronie') {
                    // 后退150米，上升80米
                    const dist = 150 * state.t;
                    const height = 80 * state.t;
                    dronePos.copy(state.startPos).add(new THREE.Vector3(0, height, dist));
                    
                    // 始终看向目标
                    droneGroup.lookAt(state.targetLookAt);
                    gimbal.rotation.set(0,0,0);
                }
                
                // --- 冲天 (Rocket) ---
                else if (state.mode === 'rocket') {
                    const height = 120 * state.t;
                    dronePos.copy(state.startPos).setY(10 + height);
                    
                    // 机身水平
                    droneGroup.rotation.set(0, 0, 0);
                    // 云台垂直向下
                    // 使用 lookAt 技巧让云台永远看向正下方的目标
                    // Rocket 模式下目标在 (0,0,0) 正下方，所以 Gimbal LookAt 即可
                    gimbal.lookAt(state.targetLookAt);
                }

                // --- 环绕 (Circle) ---
                else if (state.mode === 'circle') {
                    // **半径加大到 65米**
                    const radius = 65; 
                    const angle = state.t * Math.PI * 2; // 绕一圈
                    
                    // 假设起始点在正前方 Z+
                    // 起始角度设为 0，对应 cos=1, sin=0 -> (0, z=radius)
                    // Math.sin/cos 组合让它顺时针或逆时针转
                    dronePos.x = Math.sin(angle) * radius;
                    dronePos.z = Math.cos(angle) * radius;
                    dronePos.y = 20; // 固定高度

                    droneGroup.lookAt(state.targetLookAt);
                    gimbal.rotation.set(0,0,0);
                }

                // --- 螺旋 (Helix) ---
                else if (state.mode === 'helix') {
                    const angle = state.t * Math.PI * 4; // 2圈
                    const radius = 15 + 80 * state.t; // 15米 -> 95米
                    const height = 10 + 70 * state.t; 
                    
                    dronePos.x = Math.sin(angle) * radius;
                    dronePos.z = Math.cos(angle) * radius;
                    dronePos.y = height;

                    droneGroup.lookAt(state.targetLookAt);
                    gimbal.rotation.set(0,0,0);
                }

                // --- 彗星 (Boomerang) [重点修改] ---
                else if (state.mode === 'boomerang') {
                    // 轨迹方程：倾斜的椭圆
                    // t: 0 -> 1
                    // 角度范围：从右前方(45度) 绕一圈 回到 右前方
                    const startAngle = Math.PI / 4; 
                    const totalAngle = Math.PI * 2;
                    const currentAngle = startAngle + totalAngle * state.t;

                    // 椭圆参数
                    const widthX = 50;  // 宽度 (左右)
                    const depthZ = 100; // 深度 (前后)，拉长一点

                    // 平面位置
                    dronePos.x = Math.sin(currentAngle) * widthX;
                    dronePos.z = Math.cos(currentAngle) * depthZ;

                    // **高度计算 (Tilt Logic)**
                    // 逻辑：Z轴越小（越靠后，负数），高度越高。Z轴越大（越靠前，正数），高度越低。
                    // 设定中心高度 35米，倾斜斜率 0.4
                    // 当 z = -100 (最远), y = 35 - (-100)*0.4 = 75米
                    // 当 z = 100 (最近), y = 35 - (100)*0.4 = -5米 (太低了，调整参数)
                    
                    // 修正高度公式：
                    // 基准高度 40米。当在人身后(-Z)时加高，在人身前(+Z)时降低。
                    // 使用 -Z 作为增量
                    const slope = 0.35; 
                    dronePos.y = 40 + (-dronePos.z * slope);

                    // 限制最低高度，防止钻地
                    if(dronePos.y < 5) dronePos.y = 5;

                    droneGroup.lookAt(state.targetLookAt);
                    gimbal.rotation.set(0,0,0);
                }

                droneGroup.position.copy(dronePos);
                updateTrail(dronePos);

                // 结束
                if (state.t >= 1) {
                    state.mode = 'idle';
                    statusText.style.opacity = 0;
                }
            } else {
                // 闲置时轻微悬停
                const time = Date.now() * 0.001;
                droneGroup.position.y += Math.sin(time) * 0.02;
            }

            controls.update();
            renderer.render(scene, camera);
        }

        // --- 交互入口 ---
        window.playMode = function(modeName, btn) {
            // UI
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            
            resetTrail();
            state.t = 0;
            state.mode = modeName;
            state.speed = 0.002; // 慢速飞行，展示细节

            // 设置起始点 (为了让连线不乱飞，强行瞬移到起点)
            // 这里我们手动计算一下 t=0 时的位置
            if (modeName === 'dronie') {
                state.startPos.set(0, 5, 10);
                statusText.innerText = "渐远 DRONIE";
                statusText.style.color = "rgba(0,112,240,0.1)";
            } 
            else if (modeName === 'rocket') {
                state.startPos.set(0, 5, 0.1); // 几乎头顶
                statusText.innerText = "冲天 ROCKET";
                statusText.style.color = "rgba(255,100,0,0.1)";
            }
            else if (modeName === 'circle') {
                // 对应 Circle 逻辑中 t=0 的位置 (sin(0)=0, cos(0)=1 -> z=radius)
                // 半径 65
                state.startPos.set(0, 20, 65);
                state.speed = 0.0015; // 环绕要慢，优雅
                statusText.innerText = "环绕 CIRCLE";
                statusText.style.color = "rgba(100,0,255,0.1)";
            }
            else if (modeName === 'helix') {
                state.startPos.set(0, 10, 15);
                statusText.innerText = "螺旋 HELIX";
                statusText.style.color = "rgba(0,200,100,0.1)";
            }
            else if (modeName === 'boomerang') {
                // 对应 Boomerang 逻辑中 t=0 的位置
                // angle = PI/4
                const ang = Math.PI/4;
                const wx = 50, dz = 100;
                const x = Math.sin(ang)*wx;
                const z = Math.cos(ang)*dz;
                const y = 40 + (-z * 0.35);
                state.startPos.set(x, y, z);
                
                statusText.innerText = "彗星 BOOMERANG";
                statusText.style.color = "rgba(200,0,200,0.1)";
            }
            
            // 瞬移
            droneGroup.position.copy(state.startPos);
            // 预先更新一次朝向，避免第一帧闪烁
            if(modeName !== 'rocket') droneGroup.lookAt(state.targetLookAt);
            else droneGroup.rotation.set(0,0,0);

            statusText.style.opacity = 1;
            statusText.style.transform = "translate(-50%, -50%) scale(1.1)";
            setTimeout(() => statusText.style.transform = "translate(-50%, -50%) scale(1)", 100);
        };

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>

</html>
